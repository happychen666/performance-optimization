# 防抖debounce
n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时

**应用：**
- 每次 resize / scroll 触发统计事件
- 文本输入的验证 （连续输入文字后发送AJAX请求进行验证，验证一次就好）
- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 手机号、邮箱验证输入检测
- 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

# 节流throttle
n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效

**应用：**

- 秒杀、抢卷按钮，按下一次后，接下来几秒不让用户继续按(也可用锁实现)
- 输入框发送补全查询
- 与mousemove keyup/keydown 等相密切联系的函数
- 滚动加载，加载更多或滚到底部监听
- 搜索框，搜索联想功能

## 一个经典的比喻:

想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应

假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制

电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖

电梯第一个人进来后，15秒后准时运送一次，这是节流

再比如：
都设置时间频率为500ms，在2秒时间内，频繁触发函数。
防抖：不管快速重复调动多少次方法，在2s后，只会执行一次；
节流：每隔 500ms 就执行一次。

<https://blog.csdn.net/qq_41996454/article/details/109783564>


# 防抖和节流的区别：
相同点：目的都是，降低回调执行频率。节省计算资源

不同点：
- 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能
- 函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次

对比防抖和节流的实现方式，防抖会比节流多调用了clearTimeout的方法，当然实现方式有很多，用自己最能快速理解的方式就好，殊途同归。

